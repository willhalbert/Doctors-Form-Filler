{"ast":null,"code":"import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\nclass InViewFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n  /**\n   * TODO: Remove this in 10.0\n   */\n  viewportFallback() {\n    /**\n     * Fire this in an rAF because, at this point, the animation state\n     * won't have flushed for the first time and there's certain logic in\n     * there that behaves differently on the initial animation.\n     */\n    requestAnimationFrame(() => {\n      this.hasEnteredView = true;\n      const {\n        onViewportEnter\n      } = this.node.getProps();\n      onViewportEnter && onViewportEnter(null);\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\" /* AnimationType.InView */, true);\n      }\n    });\n  }\n  startObserver() {\n    this.unmount();\n    const {\n      viewport = {}\n    } = this.node.getProps();\n    const {\n      root,\n      margin: rootMargin,\n      amount = \"some\",\n      once,\n      fallback = true\n    } = viewport;\n    if (typeof IntersectionObserver === \"undefined\") {\n      if (fallback) this.viewportFallback();\n      return;\n    }\n    const options = {\n      root: root ? root.current : undefined,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const onIntersectionUpdate = entry => {\n      const {\n        isIntersecting\n      } = entry;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (this.isInView === isIntersecting) return;\n      this.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\" /* AnimationType.InView */, isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      const {\n        onViewportEnter,\n        onViewportLeave\n      } = this.node.getProps();\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver === \"undefined\") return;\n    const {\n      props,\n      prevProps\n    } = this.node;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n  unmount() {}\n}\nfunction hasViewportOptionChanged(_ref) {\n  let {\n    viewport = {}\n  } = _ref;\n  let {\n    viewport: prevViewport = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return name => viewport[name] !== prevViewport[name];\n}\nexport { InViewFeature };","map":{"version":3,"names":["Feature","observeIntersection","thresholdNames","some","all","InViewFeature","constructor","arguments","hasEnteredView","isInView","viewportFallback","requestAnimationFrame","onViewportEnter","node","getProps","animationState","setActive","startObserver","unmount","viewport","root","margin","rootMargin","amount","once","fallback","IntersectionObserver","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","onViewportLeave","callback","mount","update","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","_ref","prevViewport","length","name"],"sources":["/Users/williamhalbert/Desktop/ChemE-AI/client/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs"],"sourcesContent":["import { Feature } from '../Feature.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    /**\n     * TODO: Remove this in 10.0\n     */\n    viewportFallback() {\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won't have flushed for the first time and there's certain logic in\n         * there that behaves differently on the initial animation.\n         */\n        requestAnimationFrame(() => {\n            this.hasEnteredView = true;\n            const { onViewportEnter } = this.node.getProps();\n            onViewportEnter && onViewportEnter(null);\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\" /* AnimationType.InView */, true);\n            }\n        });\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = \"some\", once, fallback = true, } = viewport;\n        if (typeof IntersectionObserver === \"undefined\") {\n            if (fallback)\n                this.viewportFallback();\n            return;\n        }\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\"whileInView\" /* AnimationType.InView */, isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === \"undefined\")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\nexport { InViewFeature };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}